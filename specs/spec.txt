BEGIN MASTER SPEC v1.0

# VO Foundry — Master Technical Specification
Version: 1.0.0
Status: Ratified (MVP scope locked)
Editors: Lead Software Architect (you), Implementation Team (2–3 engineers)
Date: 2025-11-02
License: Internal use only

=====================================================================
0) CONTEXT AND GOALS
=====================================================================

Purpose:
VO Foundry is a fully local, offline-only voice-over production, review, and approval system. It manages actors, dialogue lines, takes, approval decisions, and exports. The system uses flat JSON files stored on the filesystem. All content must remain human-editable and human-repairable.

Primary MVP Goals:
– Manage actor records, dialogue records, and all (actor × dialogue) combinations (called Pairs).
– Allow unlimited takes per Pair.
– Allow unlimited approved takes per Pair.
– A Pair is only marked Complete when a reviewer explicitly toggles it.
– No auto-regeneration of takes. All generation, re-recording, and re-ingest is manual.
– Use JSON, JSONL, and CSV as the only data formats.
– Provide a deterministic audio pipeline using ffmpeg.
– Provide a CLI and a simple local web UI.
– Ensure every written data file validates against a strict JSON Schema.
– Enforce rigid versioning and change-control rules to eliminate vibe coding.

Non-Goals (MVP):
– No cloud services.
– No multi-user servers.
– No real-time collaboration.
– No DAW-level audio editing.
– No automatic TTS unless manually triggered and stored locally.
– No ML inference models required.

=====================================================================
1) ARCHITECTURE OVERVIEW
=====================================================================

Components:
– Data Layer: flat JSON, JSONL, and CSV files stored under project_root.
– Validation Layer: JSON Schema (Draft-07), validated on every write.
– CLI Layer: Node.js-based, deterministic output, no side effects.
– Local Web UI: served from localhost only, zero network egress.
– Audio Pipeline: ffmpeg for probing, normalization, transcoding.
– Task Runner: deterministic queue for batch operations; no background daemons.

Process Flow:
1. Import actors and dialogue lines.
2. System generates all valid Pairs or user generates them manually.
3. User records / imports takes.
4. Reviewer approves any number of takes.
5. Reviewer marks Pair Complete.
6. Export step bundles approved takes and metadata.

=====================================================================
2) IDENTIFIERS AND TIMEKEEPING
=====================================================================

ID Type:
Use UUIDv7 for all IDs (actors, dialogues, pairs, takes, jobs, reviews).

Timestamps:
All timestamps standardized as ISO 8601 UTC: YYYY-MM-DDTHH:mm:ss.sssZ

Hashes:
All audio files receive a SHA-256 content hash, stored in the Take record.

=====================================================================
3) DATA MODEL OVERVIEW
=====================================================================

Entities:
– Project
– Actor
– Dialogue
– Pair (actor × dialogue)
– Take
– Review Event
– Transform Job
– Export Package

Rules:
– A Pair may have 0, 1, or many Takes.
– A Pair may have 0, 1, or many approved Takes.
– Complete flag is independent of approval.
– Regeneration or new takes happen only when the user commands it.

Relationships:
– Actor has many Pairs.
– Dialogue has many Pairs.
– Pair has many Takes.
– Takes belong to exactly one Pair.
– Reviews are append-only events referring to Takes or Pairs.

=====================================================================
4) JSON SCHEMAS (FLATTENED DESCRIPTIONS)
=====================================================================

Note: In this flattened version, schemas are described structurally instead of using fenced code.

Schema: project.json
Fields:
id: uuidv7 string
name: string
schema_version: "1.0.0"
created_at: datetime
updated_at: datetime
settings: object with fields
  media_root: string
  sample_rate: 44100 or 48000
  bit_depth: 16 or 24
  channels: 1 or 2
  lufs_target: number
  peak_ceiling_db: number (default -1.0)
  lra_max: number (default 12.0)

Schema: actor.json
Fields:
id: uuidv7
display_name: string
aliases: array of strings
notes: string
created_at: datetime
updated_at: datetime

Schema: dialogue.json
Fields:
id: uuidv7
scene: string
line_number: string
character: string
text: string
context: string
direction: string
tags: array of strings
created_at: datetime
updated_at: datetime

Schema: pair.json
Fields:
id: uuidv7
actor_id: uuidv7
dialogue_id: uuidv7
state: Planned | Recording | Review | OnHold | Done
complete: boolean
notes: string
approved_take_ids: array of uuidv7, unique
created_at: datetime
updated_at: datetime

Schema: take.json
Fields:
id: uuidv7
pair_id: uuidv7
path: relative file path
hash_sha256: hex string
duration_sec: number
format: wav | flac | aiff
sample_rate: 44100 or 48000
bit_depth: 16 or 24
channels: 1 or 2
lufs_integrated: number
peak_dbfs: number
transform_chain: array of objects
  job_id: uuidv7
  name: string
  params: object
created_at: datetime
updated_at: datetime

Schema: review.json
Fields:
id: uuidv7
entity: "take" or "pair"
entity_id: uuidv7
action:
  approve_take
  reject_take
  unapprove_take
  mark_complete
  unmark_complete
  note
note: optional string
at: datetime

=====================================================================
5) FILESYSTEM LAYOUT
=====================================================================

Directory structure:

project_root/
  project.json
  catalog/
    actors.jsonl
    dialogues.jsonl
    pairs.jsonl
    takes.jsonl
    reviews.jsonl
    indexes/
      by_actor/{actor_id}.json
      by_dialogue/{dialogue_id}.json
      by_pair/{pair_id}.json
  media/
    actors/{actor_id}/pairs/{pair_id}/raw/{hash}.{ext}
    actors/{actor_id}/pairs/{pair_id}/proc/{take_id}.{ext}
  exports/
    timestamp-export_id/
      manifest.json
      audio/
      sheets/
        takes.csv
        pairs.csv
        cue_sheet.csv
  schema/
  scripts/
  .vof/
    migrations/
    audit.log

Notes:
– JSONL is append-only, easy to repair manually.
– Indexes are derived; can always be rebuilt.

=====================================================================
6) STATE MACHINES
=====================================================================

Pair State Machine:
Planned → Recording → Review → Done
             ↘ OnHold ↗

Transitions:
Planned → Recording
Recording → Review
Review → Recording
Any → OnHold
OnHold → Planned | Recording | Review
Review → Done

Complete Flag Rules:
Independent from state.
Can be toggled on or off at any time.
Approval does not affect Complete automatically.

Review Actions:
approve_take(take_id)
unapprove_take(take_id)
reject_take(take_id)
mark_complete(pair_id)
unmark_complete(pair_id)

=====================================================================
7) CSV AND JSON IMPORT/EXPORT RULES
=====================================================================

Dialogue CSV:
Columns: scene, line_number, character, text, direction, tags

Actor CSV:
Columns: display_name, aliases, notes

Export CSV files:
takes.csv includes take metadata
pairs.csv includes approvals and completion
cue_sheet.csv includes final selected takes

JSON Import Rules:
All JSON files must validate against their schemas.
IDs may be auto-generated if omitted.

=====================================================================
8) AUDIO PIPELINE
=====================================================================

Requirements:
ffmpeg must be installed.
Canonical audio format set in project settings (e.g., wav 48kHz 24bit mono).

Take Ingest Steps:
1. Probe file using ffprobe.
2. Normalize to target LUFS and peak ceiling.
3. Transcode to canonical format.
4. Hash content.
5. Save both raw and proc versions.
6. Update take record with metrics.

Determinism:
Running the same transformation chain over the same audio must produce identical output.

=====================================================================
9) VALIDATION AND INTEGRITY
=====================================================================

Every write operation validates data against schema.
All audio hashes must match actual files.
Index rebuild command reconstructs derived indexes.
fs check command validates file presence, hashes, and schema.

=====================================================================
10) CLI SPECIFICATION
=====================================================================

CLI commands include:

vof init
vof import dialogues
vof import actors
vof pairs plan
vof take add
vof take list
vof review approve
vof review unapprove
vof pair complete
vof pair state
vof export bundle
vof index rebuild
vof fs check
vof schema validate
vof migrate
vof report summary

All mutating commands append a review event.

=====================================================================
11) LOCAL WEB UI
=====================================================================

The local UI runs on localhost only.
Served via Fastify.
Zero external network access allowed.

Screens:
Dashboard
Pairs Board
Pair Detail
Exports Page

UX Rules:
No auto-complete on approval.
No hidden state changes.
Regenerate (if enabled post-MVP) must be manual.

=====================================================================
12) LOCAL API
=====================================================================

REST endpoints under /api/v1/:
actors
dialogues
pairs
takes
reviews
export
health

All POST/PUT/PATCH must validate data.

=====================================================================
13) INDEXES AND QUERIES
=====================================================================

Indexes exist only as derived caches. All truth lives in the JSONL files.

Derived Indexes:
– by_actor/{actor_id}.json
  Contains list of pair_ids, count summaries, and last updated timestamp.

– by_dialogue/{dialogue_id}.json
  Contains list of pair_ids and summary.

– by_pair/{pair_id}.json
  Summarizes pair info, take_ids, approved_take_ids, state, complete flag.

Index Rebuild:
The command vof index rebuild reads all JSONL files, reconstructs indexes, validates references, and overwrites the index directory.

Query Rules:
– All fuzzy actor names resolve deterministically to exact actor_id.
– Filters apply in canonical order: scene → actor → tags → state.


=====================================================================
14) VERSIONING AND MIGRATIONS
=====================================================================

Version Number:
schema_version = "1.0.0"

Migrations:
– All changes to schemas require a migration script.
– Migrations operate on JSONL streams.
– Migrations must be deterministic and idempotent when possible.
– downgrades may not always be possible; if not, document it clearly.

Migration Log:
Stored in .vof/audit.log
Includes timestamp, schema change, and operator identifier if provided.

Rules:
– No schema drift without explicit change request.
– No silent addition of fields.
– No silent removal of fields.


=====================================================================
15) LOGGING AND AUDIT
=====================================================================

Review Events:
A review event is appended to reviews.jsonl for every mutating action:
approve_take
unapprove_take
reject_take
mark_complete
unmark_complete
note

Audit Log:
Human-readable log stored in .vof/audit.log.
Contains high-level operations:
import actors
import dialogues
pair planning
index rebuild
export generation
migration events

Immutability:
Events cannot be deleted automatically.
Users may manually edit JSONL files, but fs check will detect inconsistencies.


=====================================================================
16) DETERMINISTIC BUILD AND TOOLING REQUIREMENTS
=====================================================================

Node Version:
Node 20 LTS required.

Package Manager:
pnpm required.

Formatting Tools:
prettier for markdown, json, ts
eslint with strict TypeScript rules
markdownlint for spec files

TypeScript Rules:
strict = true
no implicit any
no allowJs
esModuleInterop = true

Testing:
vitest as test runner
golden-file testing for outputs
mock ffmpeg in pure unit tests
run actual ffmpeg in integration tests (optional but recommended)

Validation:
ajv for JSON Schema validation
ajv-formats for datetime and pattern validation

Continuous Verification:
pnpm run verify performs:
– lint
– typecheck
– test
– schema validate all
– fs check


=====================================================================
17) SECURITY AND PRIVACY
=====================================================================

Offline Operation:
VO Foundry never connects to the internet.
No analytics.
No telemetry.
No error reporting to external servers.

CSP:
Content Security Policy in UI blocks all external resources.

File Access:
All file operations are local and relative to project_root.

Backups:
Handled manually by the user: zip project directory or export bundle.


=====================================================================
18) RISKS AND MITIGATIONS
=====================================================================

Risk: Manual Edits Corrupt Data
Mitigation: schema validate, fs check, rebuild indexes, clear error messages.

Risk: Audio Tool Missing
Mitigation: detect at startup, provide installation instructions, allow ingest without pipeline but mark non-canonical.

Risk: Large JSONL Files
Mitigation: JSONL chosen for sequential writing; periodic compaction is optional.

Risk: Reviewer Inconsistency
Mitigation: require explicit state transitions, explicit approval, explicit completion.


=====================================================================
19) DELIVERY PLAN
=====================================================================

Milestones:

M0 – Project Skeleton (Week 1)
– folder layout
– initial schemas
– CLI skeleton
– fastify skeleton
– basic dev tooling

M1 – Data I/O (Week 2)
– JSONL read/write
– validation layer
– import actors and dialogues
– ID generation
– indexes

M2 – Audio Pipeline (Week 3)
– ffprobe integration
– normalization
– transcoding
– hash computation
– transform chain persistence

M3 – Review Mechanics (Week 4)
– approve/unapprove
– complete toggle
– pair state machine
– review events
– reports

M4 – Local UI (Week 5)
– dashboard
– pairs board
– pair detail
– waveform player
– approvals
– exports page

M5 – Export & QA (Week 6)
– bundle export
– cue sheet generation
– integrity tests
– performance checks
– documentation


Definition of Done:
– All CLI commands functional.
– UI stable and fully offline.
– Full pipeline testable on sample project.
– No validation errors on fixtures.


=====================================================================
20) NO VIBE CODING POLICY
=====================================================================

Definition:
Vibe coding is any unplanned, improvisational, inconsistent, or speculative coding that deviates from this specification.

Rules:
1. All generated code must follow this spec exactly.
2. Any deviation requires a change request and spec version bump.
3. All code must be deterministic.
4. All code must validate against schemas.
5. All code must pass lint, test, and verification steps.
6. No hidden behavior, implicit behaviors, or auto-regeneration.
7. All changes must be documented.

Goals:
Ensure stable, predictable development.
Prevent architecture drift.
Maintain long-term maintainability.


=====================================================================
21) EXAMPLE RECORDS (FLATTENED)
=====================================================================

Example Dialogue JSONL entry:
{
"id": "018e3f2e-9c1a-7d2a-bc7d-0b3d6a418001",
"scene": "S01",
"line_number": "001",
"character": "OP",
"text": "Stay frosty.",
"direction": "dry",
"tags": ["combat", "short"],
"created_at": "2025-11-02T08:00:00.000Z"
}

Example Pair JSONL entry:
{
"id": "018e3f2e-9c1a-7d2a-bc7d-0b3d6a4180aa",
"actor_id": "018e3f2e-9c1a-7d2a-bc7d-0b3d6a410123",
"dialogue_id": "018e3f2e-9c1a-7d2a-bc7d-0b3d6a418001",
"state": "Review",
"complete": false,
"approved_take_ids": [],
"created_at": "2025-11-02T08:05:00.000Z"
}

Example Take JSONL entry:
{
"id": "018e3f2e-9c1a-7d2a-bc7d-0b3d6a4180ff",
"pair_id": "018e3f2e-9c1a-7d2a-bc7d-0b3d6a4180aa",
"path": "media/actors/018e3f2e.../pairs/018e3f2e.../proc/018e3f2e....wav",
"hash_sha256": "2d711642b7...c3a8b",
"duration_sec": 2.31,
"format": "wav",
"sample_rate": 48000,
"bit_depth": 24,
"channels": 1,
"lufs_integrated": -23.1,
"peak_dbfs": -1.0,
"transform_chain": [
  {
    "job_id": "018e3f2e-...",
    "name": "normalize-ebur128",
    "params": {
      "target_lufs": -23,
      "peak_ceiling_db": -1.0
    }
  }
],
"created_at": "2025-11-02T08:06:00.000Z"
}


=====================================================================
22) DEVELOPER SETUP
=====================================================================

Prerequisites:
– Node 20+
– pnpm
– ffmpeg installed

Commands:
pnpm install
pnpm run build
pnpm run verify

Example workflow:
vof init ./demo
vof import actors actors.csv
vof import dialogues dialogues.csv
vof pairs plan
vof take add
vof review approve
vof pair complete
vof export bundle


=====================================================================
23) TESTING STRATEGY
=====================================================================

Unit Tests:
– parsers
– validators
– ID generation
– parameter calculators

Integration Tests:
– full import → take → approve → export pipeline
– hashing and file existence
– index rebuild

Golden Files:
– JSONL samples
– manifests
– command outputs

Audio Testing:
– mock ffprobe for unit tests
– real ffmpeg for integration tests when available


=====================================================================
24) OPERATIONAL PLAYBOOKS
=====================================================================

Corruption Repair:
– run schema validate
– run fs check
– rebuild indexes
– fix malformed JSONL lines manually if needed

Moving Projects:
Projects are fully portable; copy project_root as a folder.

Backup Strategy:
Zip entire project folder or export bundle directory.

=====================================================================
25) TRADE-OFFS
=====================================================================

JSONL vs Single JSON:
– JSONL allows safe append and manual repair.
– Individual entries are easy to isolate.
– Single JSON becomes too large and fragile.
Decision: JSONL is mandatory for catalog storage.

ffmpeg Dependency:
– Makes normalization and probing deterministic.
– Users must install it manually.
Decision: Acceptable for a professional workflow.

Local UI Simplicity:
– Svelte chosen for minimal bundle complexity.
– Avoids React hook complexity and reduces cognitive load.
Decision: Svelte required for MVP.

Derived Indexes:
– Cached convenience but never authoritative.
– Can always be rebuilt.
Decision: Keep indexes as derived only, never canonical.

Completion Flag Separate from Approvals:
– Gives reviewers explicit control.
– Prevents accidental completion.
Decision: Complete must always be explicit.


=====================================================================
26) GLOSSARY
=====================================================================

Actor:
A performer identity with display name, optional aliases, and notes.

Dialogue:
A line of script associated with scene, line number, and text.

Pair:
A single (actor × dialogue) production unit requiring one or more takes.

Take:
An individual audio recording attempt tied to a Pair.

Review Event:
An immutable audit entry representing actions like approvals or completion.

Transform Chain:
A sequence of deterministic audio processing steps applied to a take.

Derived Index:
A non-canonical JSON file summarizing relationships; can be rebuilt anytime.

Complete Flag:
Reviewer-declared finish state of a Pair, independent of approvals.

Normalization:
Audio processing step ensuring consistent loudness and peak levels.

Canonical Format:
The mandatory output audio format (typically WAV 48kHz/24bit/mono).

Project Root:
Top-level directory containing project.json, catalogs, media, schemas, and indexes.

Vibe Coding:
Undisciplined or improvisational coding contrary to the formal spec; strictly forbidden.


=====================================================================
END MASTER SPEC v1.0
=====================================================================

