BEGIN MASTER SPEC v2.0

# VO Foundry — Master Technical Specification
Version: 2.0.0 (Actor-Centric Model + ElevenLabs Integration)
Status: Ratified
Editors: Lead Software Architect (you), Implementation Team (2–3 engineers)
Date: 2025-11-23
License: Internal use only

=====================================================================
0) CONTEXT AND GOALS
=====================================================================

Purpose:
VO Foundry is a fully local voice-over production, review, and approval system with integrated ElevenLabs audio generation. It manages actors, content items (dialogue/music/SFX), takes, approval decisions, and exports. The system uses flat JSON files stored on the filesystem. All content must remain human-editable and human-repairable.

Primary MVP Goals:
– Manage actor records with provider settings for audio generation.
– Manage content items (dialogue, music, SFX) owned by actors.
– Generate audio via ElevenLabs API in batch mode.
– Allow unlimited takes per content item.
– Allow unlimited approved takes per content item.
– User-controlled completion flags at actor, content-type, and content-item levels.
– Use JSON, JSONL, and CSV as the only data formats.
– Provide a deterministic audio pipeline using ffmpeg.
– Provide a CLI and a tree-based local web UI.
– Ensure every written data file validates against a strict JSON Schema.
– Enforce rigid versioning and change-control rules to eliminate vibe coding.

Non-Goals (MVP):
– No cloud services.
– No multi-user servers.
– No real-time collaboration.
– No DAW-level audio editing.
– No ML inference models required.

=====================================================================
1) ARCHITECTURE OVERVIEW
=====================================================================

Components:
– Data Layer: flat JSON, JSONL, and CSV files stored under project_root.
– Validation Layer: JSON Schema (Draft-07), validated on every write.
– Service Layer: Core business logic (imports, generation, audio processing) decoupled from interfaces.
– Provider Layer: ElevenLabs API client with retry logic and quota tracking.
– CLI Layer: Thin wrapper around Service Layer; Node.js-based, deterministic output.
– Local Web UI: Tree/file-explorer interface; served from localhost only.
– Audio Pipeline: ffmpeg for probing, normalization, transcoding.

Layered Architecture Rule:
1. CLI and API (Web UI) must NEVER contain business logic.
2. All business logic must reside in `src/services/`.
3. CLI commands and API routes simply parse input, call a Service, and format output.

Data Model Hierarchy:
Project
└── Actors
    └── Actor
        ├── Provider Settings (per content type)
        ├── Dialogue Items
        │   └── Takes
        ├── Music Items
        │   └── Takes
        └── SFX Items
            └── Takes

Process Flow:
1. Import or create actors with provider settings.
2. Add content items (dialogue/music/SFX) to actors.
3. Run batch generation to create takes via ElevenLabs API.
4. Review takes: approve, reject, or regenerate.
5. Mark content items as complete when satisfied.
6. Export approved takes and metadata.

=====================================================================
2) IDENTIFIERS AND TIMEKEEPING
=====================================================================

ID Type:
Use UUIDv7 for all IDs (actors, content, takes, jobs).

Timestamps:
All timestamps standardized as ISO 8601 UTC: YYYY-MM-DDTHH:mm:ss.sssZ

Hashes:
All audio files receive a SHA-256 content hash, stored in the Take record.

File Naming Convention:
{base_filename}{item_id}_{take_number}.{ext}
Example: john_wick_my_name_001.wav

=====================================================================
3) DATA MODEL OVERVIEW
=====================================================================

Entities:
– Project
– Actor
– Content (dialogue, music, or SFX item)
– Take
– Generation Job

Rules:
– An Actor owns many Content items.
– A Content item may have 0, 1, or many Takes.
– A Content item may have 0, 1, or many approved Takes.
– Complete flags are user-controlled at actor, content-type, and content-item levels.
– Generation happens only when user triggers batch build.

Relationships:
– Actor has many Content items.
– Content belongs to exactly one Actor.
– Content has many Takes.
– Takes belong to exactly one Content item.

=====================================================================
4) JSON SCHEMAS (FLATTENED DESCRIPTIONS)
=====================================================================

Schema: project.json
Fields:
id: uuidv7 string
name: string
schema_version: "2.0.0"
created_at: datetime
updated_at: datetime
settings: object with fields
  media_root: string
  sample_rate: 44100 or 48000
  bit_depth: 16 or 24
  channels: 1 or 2
  lufs_target: number
  peak_ceiling_db: number (default -1.0)
  lra_max: number (default 12.0)

Schema: actor.json
Fields:
id: uuidv7
display_name: string
base_filename: string (e.g., "john_wick_")
all_approved: boolean (user-controlled)
provider_settings: object with fields per content type
  dialogue:
    provider: "elevenlabs"
    voice_id: string
    batch_generate: number (takes per BUILD)
    approval_count_default: number (target approved takes)
    stability: number (0-1)
    similarity_boost: number (0-1)
  music:
    provider: "elevenlabs"
    batch_generate: number
    approval_count_default: number
  sfx:
    provider: "elevenlabs"
    batch_generate: number
    approval_count_default: number
created_at: datetime
updated_at: datetime

Schema: content.json
Fields:
id: uuidv7
actor_id: uuidv7
content_type: "dialogue" | "music" | "sfx"
item_id: string (combined with base_filename for file naming)
prompt: string (dialogue text or music/SFX description)
complete: boolean (user-controlled)
all_approved: boolean (user-controlled)
tags: array of strings
created_at: datetime
updated_at: datetime

Schema: take.json
Fields:
id: uuidv7
content_id: uuidv7
take_number: integer (sequential, 1-indexed)
filename: string (e.g., "john_wick_my_name_001.wav")
status: "new" | "approved" | "rejected" | "hidden"
path: relative file path
hash_sha256: hex string
duration_sec: number
format: wav | flac | aiff
sample_rate: 44100 or 48000
bit_depth: 16 or 24
channels: 1 or 2
lufs_integrated: number
peak_dbfs: number
generated_by: "elevenlabs" | "manual" | null
generation_params: object
  voice_id: string
  stability: number
  (provider-specific params)
created_at: datetime

Schema: generation-job.json
Fields:
id: uuidv7
status: "pending" | "running" | "completed" | "failed"
items: array of objects
  content_id: uuidv7
  actor_id: uuidv7
  take_count: number
  status: "pending" | "generating" | "done" | "error"
  error_message: string (optional)
created_at: datetime
completed_at: datetime
error_log: array of strings

=====================================================================
5) FILESYSTEM LAYOUT
=====================================================================

Directory structure:

project_root/
  project.json
  catalog/
    actors.jsonl
    content.jsonl
    takes.jsonl
    generation-jobs.jsonl
    indexes/
      by_actor/{actor_id}.json
      by_content/{content_id}.json
  media/
    actors/{actor_id}/
      dialogue/{content_id}/
        raw/{base_filename}{item_id}_{take_number}.wav
        proc/{base_filename}{item_id}_{take_number}_normalized.wav
      music/{content_id}/...
      sfx/{content_id}/...
  exports/
    timestamp-export_id/
      manifest.json
      audio/
      sheets/
        takes.csv
        content.csv
  schema/
  .vof/
    config.json
    audit.log

Notes:
– JSONL is append-only, easy to repair manually.
– Indexes are derived; can always be rebuilt.
– No pairs.jsonl (Pair concept removed in v2.0).

=====================================================================
6) BATCH GENERATION LOGIC
=====================================================================

When user triggers BUILD (vof generate batch):

1. Find all content items where complete = false
2. For each item:
   a. Count approved takes
   b. Get approval_count_target from actor.provider_settings.{content_type}.approval_count_default
   c. If approved_count < approval_count_target:
      - Calculate needed = approval_count_target - approved_count
      - Generate 'needed' new takes via provider API
3. Skip items where complete = true
4. Log each generation attempt
5. Retry failed generations 3 times
6. Report summary: success count, failure count, takes created

Example:
- john_wick.provider_settings.dialogue.approval_count_default = 3
- my_name has 2 takes: 1 approved, 1 rejected
- approved_count = 1, target = 3
- Generate 3 - 1 = 2 more takes

Special Cases:
- If one take is exceptionally good, user can mark complete even with approved_count < target
- If complete = true, skip generation regardless of approved_count

=====================================================================
7) PROVIDER INTEGRATION (ELEVENLABS)
=====================================================================

ElevenLabs API Client:
- generateDialogue(text, voiceId, settings) → audio buffer
- generateMusic(prompt, settings) → audio buffer
- generateSFX(prompt, settings) → audio buffer
- getQuotaInfo() → usage stats

Error Handling:
- Retry failed API calls 3 times with exponential backoff
- Log all errors to generation-job.error_log
- Skip failed items and continue batch
- Report all errors at end of batch

Configuration:
Stored in .vof/config.json:
{
  "providers": {
    "elevenlabs": {
      "api_key": "sk-...",
      "api_url": "https://api.elevenlabs.io/v1"
    }
  },
  "generation": {
    "default_format": "wav",
    "auto_normalize": true,
    "auto_transcode_formats": ["mp3"]
  }
}

Quota Tracking:
- Display usage before/after batch generation
- Warn if quota is low
- No automatic quota enforcement (user responsibility)

=====================================================================
8) AUDIO PIPELINE
=====================================================================

Requirements:
ffmpeg must be installed.
Canonical audio format set in project settings (e.g., wav 48kHz 24bit mono).

Take Ingest Steps:
1. Probe file using ffprobe.
2. Normalize to target LUFS and peak ceiling.
3. Transcode to canonical format.
4. Hash content.
5. Save both raw and proc versions.
6. Update take record with metrics.

Determinism:
Running the same transformation chain over the same audio must produce identical output.

=====================================================================
9) VALIDATION AND INTEGRITY
=====================================================================

Every write operation validates data against schema.
All audio hashes must match actual files.
Index rebuild command reconstructs derived indexes.
fs check command validates file presence, hashes, and schema.

=====================================================================
10) CLI SPECIFICATION
=====================================================================

CLI commands include:

vof init
vof import actors
vof content add --actor <name> --type <dialogue|music|sfx> --id <item_id> --prompt <text>
vof content list [--actor <name>] [--type <type>] [--incomplete]
vof content complete <content_id>
vof generate batch [--actor <name>] [--type <type>] [--dry-run]
vof generate status
vof generate quota
vof take approve <take_id>
vof take reject <take_id>
vof take regenerate <take_id>
vof config set <key> <value>
vof config list
vof export bundle
vof index rebuild
vof fs check
vof schema validate
vof migrate
vof report summary

All mutating commands append an audit log entry.

=====================================================================
11) LOCAL WEB UI
=====================================================================

The local UI runs on localhost only.
Served via Fastify.
Zero external network access allowed.

UI Structure:
Tree/file-explorer view with expandable nodes:
- Project
  - Actors
    - Actor (display_name)
      - Provider Settings (expandable)
      - Dialogue (expandable, shows all_approved checkbox)
        - Content Item (item_id, prompt)
          - Take 1 (filename, status, actions)
          - Take 2
      - Music
      - SFX

Actions:
On Actor:
- Edit provider settings
- Mark all approved / unmark

On Content Type (dialogue/music/sfx):
- Mark all approved / unmark
- Add new content item

On Content Item:
- Mark complete / incomplete
- Mark all approved / unmark
- Add take manually
- Remove from UI (soft delete)

On Take:
- Approve
- Reject
- Play (audio player)
- Regenerate
- Hide/Show (via filter toggle)

Filtering/Search:
- Search by: actor name, item_id, prompt text
- Filter by: content type, status (new/approved/rejected), complete flag
- Toggle: Show/Hide rejected takes

=====================================================================
12) INDEXES AND QUERIES
=====================================================================

Indexes exist only as derived caches. All truth lives in the JSONL files.

Derived Indexes:
– by_actor/{actor_id}.json
  Contains list of content_ids, count summaries, and last updated timestamp.

– by_content/{content_id}.json
  Summarizes content info, take_ids, approved_take_ids, status, complete flag.

Index Rebuild:
The command vof index rebuild reads all JSONL files, reconstructs indexes, validates references, and overwrites the index directory.

Query Rules:
– All fuzzy actor names resolve deterministically to exact actor_id.
– Filters apply in canonical order: actor → content_type → tags → status.

=====================================================================
13) VERSIONING AND MIGRATIONS
=====================================================================

Version Number:
schema_version = "2.0.0"

Breaking Changes from v1.x:
– Removed Pair entity (actor × dialogue).
– Renamed dialogue.json to content.json.
– Added content_type field (dialogue | music | sfx).
– Added actor.base_filename and actor.provider_settings.
– Added content.complete and content.all_approved flags.
– Added take.status and take.generated_by fields.

Migrations:
– All changes to schemas require a migration script.
– Migrations operate on JSONL streams.
– Migrations must be deterministic and idempotent when possible.
– Downgrades may not always be possible; if not, document it clearly.

Migration Log:
Stored in .vof/audit.log
Includes timestamp, schema change, and operator identifier if provided.

Rules:
– No schema drift without explicit change request.
– No silent addition of fields.
– No silent removal of fields.

=====================================================================
14) LOGGING AND AUDIT
=====================================================================

Audit Log:
Human-readable log stored in .vof/audit.log.
Contains high-level operations:
import actors
add content
batch generation
approve/reject take
mark complete
index rebuild
export generation
migration events

Immutability:
Events cannot be deleted automatically.
Users may manually edit JSONL files, but fs check will detect inconsistencies.

=====================================================================
15) DETERMINISTIC BUILD AND TOOLING REQUIREMENTS
=====================================================================

Node Version:
Node 20 LTS required.

Package Manager:
pnpm required.

Formatting Tools:
prettier for markdown, json, ts
eslint with strict TypeScript rules
markdownlint for spec files

TypeScript Rules:
strict = true
no implicit any
no allowJs
esModuleInterop = true

Testing:
vitest as test runner
golden-file testing for outputs
mock ElevenLabs API in pure unit tests
run actual ElevenLabs API in integration tests (optional, requires API key)

Validation:
ajv for JSON Schema validation
ajv-formats for datetime and pattern validation

Continuous Verification:
pnpm run verify performs:
– lint
– typecheck
– test
– schema validate all
– fs check

=====================================================================
16) SECURITY AND PRIVACY
=====================================================================

Offline Operation:
VO Foundry connects to ElevenLabs API only for audio generation.
No analytics.
No telemetry.
No error reporting to external servers.

API Key Security:
Stored in .vof/config.json (local file).
User responsible for key security.
Never log or display full API key.

CSP:
Content Security Policy in UI blocks all external resources except ElevenLabs API.

File Access:
All file operations are local and relative to project_root.

Backups:
Handled manually by the user: zip project directory or export bundle.

=====================================================================
17) RISKS AND MITIGATIONS
=====================================================================

Risk: Manual Edits Corrupt Data
Mitigation: schema validate, fs check, rebuild indexes, clear error messages.

Risk: Audio Tool Missing
Mitigation: detect at startup, provide installation instructions, allow ingest without pipeline but mark non-canonical.

Risk: Large JSONL Files
Mitigation: JSONL chosen for sequential writing; periodic compaction is optional.

Risk: ElevenLabs API Failure
Mitigation: retry logic, skip failed items, continue batch, report errors at end.

Risk: API Quota Exceeded
Mitigation: display quota before/after generation, warn if low, user responsibility to manage.

=====================================================================
18) DELIVERY PLAN
=====================================================================

Milestones:

M0 – Project Skeleton (Week 1)
– folder layout
– initial schemas
– CLI skeleton
– fastify skeleton
– basic dev tooling

M1 – Data I/O (Week 2)
– JSONL read/write
– validation layer
– import actors
– ID generation
– indexes
– Service Layer refactor

M2 – Audio Pipeline (Week 3)
– ffprobe integration
– normalization
– transcoding
– hash computation

M2.5 – Audio Generation (Week 4)
– ElevenLabs API client
– provider interface
– batch generation service
– config management
– CLI commands (generate, config)

M3 – Review Mechanics (Week 5)
– approve/reject actions
– complete toggle
– content management
– audit logging
– reports

M4 – Local UI (Week 6)
– tree/file-explorer interface
– provider settings editor
– content item management
– take approval interface
– audio player
– filtering/search

M5 – Export & QA (Week 7)
– bundle export
– cue sheet generation
– integrity tests
– performance checks
– documentation

Definition of Done:
– All CLI commands functional.
– UI stable and fully offline.
– Full pipeline testable on sample project.
– No validation errors on fixtures.

=====================================================================
19) NO VIBE CODING POLICY
=====================================================================

Definition:
Vibe coding is any unplanned, improvisational, inconsistent, or speculative coding that deviates from this specification.

Rules:
1. All generated code must follow this spec exactly.
2. Any deviation requires a change request and spec version bump.
3. All code must be deterministic.
4. All code must validate against schemas.
5. All code must pass lint, test, and verification steps.
6. No hidden behavior, implicit behaviors, or auto-regeneration.
7. All changes must be documented.

Goals:
Ensure stable, predictable development.
Prevent architecture drift.
Maintain long-term maintainability.

=====================================================================
20) GLOSSARY
=====================================================================

Actor:
A performer identity with display name, base filename, and provider settings.

Content:
A dialogue line, music cue, or SFX item owned by an actor.

Content Type:
One of: dialogue, music, or sfx.

Take:
An individual audio recording attempt tied to a Content item.

Batch Generation:
Process of generating multiple takes for incomplete content items via provider API.

Provider:
External service for audio generation (e.g., ElevenLabs).

Complete Flag:
User-declared finish state of a Content item, independent of approvals.

All Approved Flag:
User-declared state indicating all takes for a content item/type/actor are satisfactory.

Approval Count Default:
Target number of approved takes for a content type, used in batch generation logic.

Batch Generate:
Number of takes to generate per content item during a BUILD run.

Base Filename:
Actor's filename prefix (e.g., "john_wick_") used for all generated files.

Item ID:
Content item's identifier (e.g., "my_name") combined with base_filename for file naming.

Normalization:
Audio processing step ensuring consistent loudness and peak levels.

Canonical Format:
The mandatory output audio format (typically WAV 48kHz/24bit/mono).

Project Root:
Top-level directory containing project.json, catalogs, media, schemas, and indexes.

Vibe Coding:
Undisciplined or improvisational coding contrary to the formal spec; strictly forbidden.

=====================================================================
END MASTER SPEC v2.0
=====================================================================
